[{"model": "admin.logentry", "pk": 1, "fields": {"action_time": "2023-08-08T14:52:49.677Z", "user": 1, "content_type": 8, "object_id": "1", "object_repr": "Алгоритмы", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 2, "fields": {"action_time": "2023-08-08T14:53:59.727Z", "user": 1, "content_type": 9, "object_id": "1", "object_repr": "Квадратичные сортировки", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 3, "fields": {"action_time": "2023-08-08T14:57:36.311Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Сортировка пузырьком / Bubble sort", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (1)\"}}]"}}, {"model": "admin.logentry", "pk": 4, "fields": {"action_time": "2023-08-08T14:59:45.745Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "Сортировка вставкой / Insert sort", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (2)\"}}]"}}, {"model": "admin.logentry", "pk": 5, "fields": {"action_time": "2023-08-08T15:01:12.553Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Сортировка выбором / Choice sort", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (3)\"}}]"}}, {"model": "admin.logentry", "pk": 6, "fields": {"action_time": "2023-08-08T16:13:41.795Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Сортировка выбором / Choice sort", "action_flag": 2, "change_message": "[{\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (4)\"}}]"}}, {"model": "admin.logentry", "pk": 7, "fields": {"action_time": "2023-08-08T19:22:44.308Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Сортировка выбором / Choice sort", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Python \\u043a\\u043e\\u0434\"]}}]"}}, {"model": "admin.logentry", "pk": 8, "fields": {"action_time": "2023-08-09T15:15:04.209Z", "user": 1, "content_type": 8, "object_id": "2", "object_repr": "ООП (Объектно - ориентированное программирование)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 9, "fields": {"action_time": "2023-08-09T15:15:41.431Z", "user": 1, "content_type": 9, "object_id": "2", "object_repr": "Рекурсия", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 10, "fields": {"action_time": "2023-08-09T15:21:32.736Z", "user": 1, "content_type": 7, "object_id": "4", "object_repr": "Бинарный поиск", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (5)\"}}]"}}, {"model": "admin.logentry", "pk": 11, "fields": {"action_time": "2023-08-09T15:24:46.987Z", "user": 1, "content_type": 7, "object_id": "5", "object_repr": "Сортировка слияние", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (6)\"}}]"}}, {"model": "admin.logentry", "pk": 12, "fields": {"action_time": "2023-08-09T15:25:05.336Z", "user": 1, "content_type": 7, "object_id": "5", "object_repr": "Сортировка слиянием", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"\\u0417\\u0430\\u0434\\u0430\\u0447\\u0430\"]}}]"}}, {"model": "admin.logentry", "pk": 13, "fields": {"action_time": "2023-08-09T16:22:29.499Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Последовательность Фибоначчи рекурсивно", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (7)\"}}]"}}, {"model": "admin.logentry", "pk": 14, "fields": {"action_time": "2023-08-09T16:56:22.279Z", "user": 1, "content_type": 7, "object_id": "7", "object_repr": "Генерация чисел", "action_flag": 1, "change_message": "[{\"added\": {}}, {\"added\": {\"name\": \"\\u0418\\u0437\\u043e\\u0431\\u0440\\u0430\\u0436\\u0435\\u043d\\u0438\\u044f\", \"object\": \"TaskImage object (8)\"}}]"}}, {"model": "admin.logentry", "pk": 15, "fields": {"action_time": "2023-08-09T18:10:18.271Z", "user": 1, "content_type": 7, "object_id": "8", "object_repr": "Геренация чисел двоичной СС", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 16, "fields": {"action_time": "2023-08-09T18:13:53.081Z", "user": 1, "content_type": 8, "object_id": "3", "object_repr": "Общий Python", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 17, "fields": {"action_time": "2023-08-09T18:15:57.479Z", "user": 1, "content_type": 7, "object_id": "9", "object_repr": "Сортировка Тони Хоара", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 18, "fields": {"action_time": "2023-08-10T15:29:51.323Z", "user": 1, "content_type": 8, "object_id": "4", "object_repr": "Тестирование", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 19, "fields": {"action_time": "2023-08-10T16:11:01.302Z", "user": 1, "content_type": 9, "object_id": "3", "object_repr": "Тестирование Assert", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 20, "fields": {"action_time": "2023-08-10T16:11:58.777Z", "user": 1, "content_type": 7, "object_id": "10", "object_repr": "Пример тестирования Assert 1", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 21, "fields": {"action_time": "2023-08-10T17:31:36.160Z", "user": 1, "content_type": 9, "object_id": "4", "object_repr": "Тестирование Unittest", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 22, "fields": {"action_time": "2023-08-10T18:09:55.199Z", "user": 1, "content_type": 9, "object_id": "5", "object_repr": "Декораторы", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 23, "fields": {"action_time": "2023-08-10T18:10:39.315Z", "user": 1, "content_type": 7, "object_id": "11", "object_repr": "Декоратор измерения времени", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 24, "fields": {"action_time": "2023-08-10T18:12:18.384Z", "user": 1, "content_type": 8, "object_id": "5", "object_repr": "Структуры данных", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 25, "fields": {"action_time": "2023-08-10T18:13:24.530Z", "user": 1, "content_type": 9, "object_id": "6", "object_repr": "Стэк (структура данных)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 26, "fields": {"action_time": "2023-08-10T18:41:20.765Z", "user": 1, "content_type": 11, "object_id": "3", "object_repr": "Comment object (3)", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 27, "fields": {"action_time": "2023-08-10T18:41:20.774Z", "user": 1, "content_type": 11, "object_id": "2", "object_repr": "Comment object (2)", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 28, "fields": {"action_time": "2023-08-10T18:41:20.779Z", "user": 1, "content_type": 11, "object_id": "1", "object_repr": "Comment object (1)", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 29, "fields": {"action_time": "2023-08-11T16:22:07.841Z", "user": 1, "content_type": 8, "object_id": "6", "object_repr": "DJANGO", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 30, "fields": {"action_time": "2023-08-11T16:22:52.778Z", "user": 1, "content_type": 8, "object_id": "7", "object_repr": "DRF (API)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 31, "fields": {"action_time": "2023-08-12T11:41:34.116Z", "user": 1, "content_type": 9, "object_id": "7", "object_repr": "Эффективные алгоритмы решения задачи 2-SUM", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 32, "fields": {"action_time": "2023-08-12T11:42:31.165Z", "user": 1, "content_type": 7, "object_id": "12", "object_repr": "Метод двух указателей", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 33, "fields": {"action_time": "2023-08-12T11:43:36.992Z", "user": 1, "content_type": 7, "object_id": "12", "object_repr": "Метод двух указателей", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Python \\u043a\\u043e\\u0434\"]}}]"}}, {"model": "admin.logentry", "pk": 34, "fields": {"action_time": "2023-08-12T11:45:45.055Z", "user": 1, "content_type": 7, "object_id": "13", "object_repr": "Метод двух указателей с дополнительной памятью", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 35, "fields": {"action_time": "2023-08-12T11:46:36.228Z", "user": 1, "content_type": 7, "object_id": "13", "object_repr": "Метод двух указателей с дополнительной памятью", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"\\u041e\\u043f\\u0438\\u0441\\u0430\\u043d\\u0438\\u0435\"]}}]"}}, {"model": "admin.logentry", "pk": 36, "fields": {"action_time": "2023-08-16T01:30:13.446Z", "user": 1, "content_type": 7, "object_id": "14", "object_repr": "Реализация stack на массиве", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 37, "fields": {"action_time": "2023-08-16T01:31:30.001Z", "user": 1, "content_type": 4, "object_id": "4", "object_repr": "Focker", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"First name\", \"Last name\"]}}]"}}, {"model": "admin.logentry", "pk": 38, "fields": {"action_time": "2023-08-16T01:31:57.597Z", "user": 1, "content_type": 7, "object_id": "14", "object_repr": "Реализация stack на массиве", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"\\u0410\\u0432\\u0442\\u043e\\u0440\"]}}]"}}, {"model": "admin.logentry", "pk": 39, "fields": {"action_time": "2023-08-16T02:04:31.885Z", "user": 1, "content_type": 7, "object_id": "15", "object_repr": "Проверка корректности скобочной последовательности", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "auth.permission", "pk": 1, "fields": {"name": "Can add log entry", "content_type": 1, "codename": "add_logentry"}}, {"model": "auth.permission", "pk": 2, "fields": {"name": "Can change log entry", "content_type": 1, "codename": "change_logentry"}}, {"model": "auth.permission", "pk": 3, "fields": {"name": "Can delete log entry", "content_type": 1, "codename": "delete_logentry"}}, {"model": "auth.permission", "pk": 4, "fields": {"name": "Can view log entry", "content_type": 1, "codename": "view_logentry"}}, {"model": "auth.permission", "pk": 5, "fields": {"name": "Can add permission", "content_type": 2, "codename": "add_permission"}}, {"model": "auth.permission", "pk": 6, "fields": {"name": "Can change permission", "content_type": 2, "codename": "change_permission"}}, {"model": "auth.permission", "pk": 7, "fields": {"name": "Can delete permission", "content_type": 2, "codename": "delete_permission"}}, {"model": "auth.permission", "pk": 8, "fields": {"name": "Can view permission", "content_type": 2, "codename": "view_permission"}}, {"model": "auth.permission", "pk": 9, "fields": {"name": "Can add group", "content_type": 3, "codename": "add_group"}}, {"model": "auth.permission", "pk": 10, "fields": {"name": "Can change group", "content_type": 3, "codename": "change_group"}}, {"model": "auth.permission", "pk": 11, "fields": {"name": "Can delete group", "content_type": 3, "codename": "delete_group"}}, {"model": "auth.permission", "pk": 12, "fields": {"name": "Can view group", "content_type": 3, "codename": "view_group"}}, {"model": "auth.permission", "pk": 13, "fields": {"name": "Can add user", "content_type": 4, "codename": "add_user"}}, {"model": "auth.permission", "pk": 14, "fields": {"name": "Can change user", "content_type": 4, "codename": "change_user"}}, {"model": "auth.permission", "pk": 15, "fields": {"name": "Can delete user", "content_type": 4, "codename": "delete_user"}}, {"model": "auth.permission", "pk": 16, "fields": {"name": "Can view user", "content_type": 4, "codename": "view_user"}}, {"model": "auth.permission", "pk": 17, "fields": {"name": "Can add content type", "content_type": 5, "codename": "add_contenttype"}}, {"model": "auth.permission", "pk": 18, "fields": {"name": "Can change content type", "content_type": 5, "codename": "change_contenttype"}}, {"model": "auth.permission", "pk": 19, "fields": {"name": "Can delete content type", "content_type": 5, "codename": "delete_contenttype"}}, {"model": "auth.permission", "pk": 20, "fields": {"name": "Can view content type", "content_type": 5, "codename": "view_contenttype"}}, {"model": "auth.permission", "pk": 21, "fields": {"name": "Can add session", "content_type": 6, "codename": "add_session"}}, {"model": "auth.permission", "pk": 22, "fields": {"name": "Can change session", "content_type": 6, "codename": "change_session"}}, {"model": "auth.permission", "pk": 23, "fields": {"name": "Can delete session", "content_type": 6, "codename": "delete_session"}}, {"model": "auth.permission", "pk": 24, "fields": {"name": "Can view session", "content_type": 6, "codename": "view_session"}}, {"model": "auth.permission", "pk": 25, "fields": {"name": "Can add Задачи", "content_type": 7, "codename": "add_task"}}, {"model": "auth.permission", "pk": 26, "fields": {"name": "Can change Задачи", "content_type": 7, "codename": "change_task"}}, {"model": "auth.permission", "pk": 27, "fields": {"name": "Can delete Задачи", "content_type": 7, "codename": "delete_task"}}, {"model": "auth.permission", "pk": 28, "fields": {"name": "Can view Задачи", "content_type": 7, "codename": "view_task"}}, {"model": "auth.permission", "pk": 29, "fields": {"name": "Can add Категории", "content_type": 8, "codename": "add_category"}}, {"model": "auth.permission", "pk": 30, "fields": {"name": "Can change Категории", "content_type": 8, "codename": "change_category"}}, {"model": "auth.permission", "pk": 31, "fields": {"name": "Can delete Категории", "content_type": 8, "codename": "delete_category"}}, {"model": "auth.permission", "pk": 32, "fields": {"name": "Can view Категории", "content_type": 8, "codename": "view_category"}}, {"model": "auth.permission", "pk": 33, "fields": {"name": "Can add Темы", "content_type": 9, "codename": "add_subject"}}, {"model": "auth.permission", "pk": 34, "fields": {"name": "Can change Темы", "content_type": 9, "codename": "change_subject"}}, {"model": "auth.permission", "pk": 35, "fields": {"name": "Can delete Темы", "content_type": 9, "codename": "delete_subject"}}, {"model": "auth.permission", "pk": 36, "fields": {"name": "Can view Темы", "content_type": 9, "codename": "view_subject"}}, {"model": "auth.permission", "pk": 37, "fields": {"name": "Can add Изображения", "content_type": 10, "codename": "add_taskimage"}}, {"model": "auth.permission", "pk": 38, "fields": {"name": "Can change Изображения", "content_type": 10, "codename": "change_taskimage"}}, {"model": "auth.permission", "pk": 39, "fields": {"name": "Can delete Изображения", "content_type": 10, "codename": "delete_taskimage"}}, {"model": "auth.permission", "pk": 40, "fields": {"name": "Can view Изображения", "content_type": 10, "codename": "view_taskimage"}}, {"model": "auth.permission", "pk": 41, "fields": {"name": "Can add Комментарии", "content_type": 11, "codename": "add_comment"}}, {"model": "auth.permission", "pk": 42, "fields": {"name": "Can change Комментарии", "content_type": 11, "codename": "change_comment"}}, {"model": "auth.permission", "pk": 43, "fields": {"name": "Can delete Комментарии", "content_type": 11, "codename": "delete_comment"}}, {"model": "auth.permission", "pk": 44, "fields": {"name": "Can view Комментарии", "content_type": 11, "codename": "view_comment"}}, {"model": "auth.user", "pk": 1, "fields": {"password": "pbkdf2_sha256$600000$HMz031OswcET9MC0oaYXPO$zi28wUbaR+r2MSx8ck5JXpUCA4y+55pW1QT78e8tBAY=", "last_login": "2023-08-16T01:12:49.649Z", "is_superuser": true, "username": "admin", "first_name": "", "last_name": "", "email": "blackaquitance@gmail.com", "is_staff": true, "is_active": true, "date_joined": "2023-08-08T14:51:53.602Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 2, "fields": {"password": "pbkdf2_sha256$600000$Ajj3aoyUsx3M92kx0wxEQn$Z8sJtdN2iuHMR4UNY5H/9Z1iWKfbgKz1GQYWgsNoYn0=", "last_login": "2023-08-13T13:13:02.284Z", "is_superuser": false, "username": "Kirill_svitsov", "first_name": "Kirill", "last_name": "Svitsov", "email": "blackaquitance@yandex.ru", "is_staff": false, "is_active": true, "date_joined": "2023-08-13T13:09:30.032Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 3, "fields": {"password": "pbkdf2_sha256$600000$OWFPr3QSkixUOS6wj1FXBF$fXdeRKaqeOfWWkVtmx2S8IeVgobq4eRtflwx19xZnlM=", "last_login": "2023-08-13T18:51:53.451Z", "is_superuser": false, "username": "ozulon", "first_name": "Ozulon", "last_name": "Ozulonov", "email": "ozulon@ozulon.com", "is_staff": false, "is_active": true, "date_joined": "2023-08-13T13:14:21.387Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 4, "fields": {"password": "pbkdf2_sha256$600000$DtdhDANzOjYSpxH8mEQnF4$446WbMuKn8OfWDDfqxozq/yTf5ozKcwImbj3EbmAhVQ=", "last_login": "2023-08-13T18:54:23Z", "is_superuser": false, "username": "Focker", "first_name": "Kventin", "last_name": "Tarantino", "email": "test@test.test", "is_staff": false, "is_active": true, "date_joined": "2023-08-13T18:54:05Z", "groups": [], "user_permissions": []}}, {"model": "contenttypes.contenttype", "pk": 1, "fields": {"app_label": "admin", "model": "logentry"}}, {"model": "contenttypes.contenttype", "pk": 2, "fields": {"app_label": "auth", "model": "permission"}}, {"model": "contenttypes.contenttype", "pk": 3, "fields": {"app_label": "auth", "model": "group"}}, {"model": "contenttypes.contenttype", "pk": 4, "fields": {"app_label": "auth", "model": "user"}}, {"model": "contenttypes.contenttype", "pk": 5, "fields": {"app_label": "contenttypes", "model": "contenttype"}}, {"model": "contenttypes.contenttype", "pk": 6, "fields": {"app_label": "sessions", "model": "session"}}, {"model": "contenttypes.contenttype", "pk": 7, "fields": {"app_label": "task", "model": "task"}}, {"model": "contenttypes.contenttype", "pk": 8, "fields": {"app_label": "task", "model": "category"}}, {"model": "contenttypes.contenttype", "pk": 9, "fields": {"app_label": "task", "model": "subject"}}, {"model": "contenttypes.contenttype", "pk": 10, "fields": {"app_label": "task", "model": "taskimage"}}, {"model": "contenttypes.contenttype", "pk": 11, "fields": {"app_label": "task", "model": "comment"}}, {"model": "sessions.session", "pk": "22b33ap9n4edwqm45jfawezq829f1en9", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2pAZhKG4dO8ZmhlAqRpISrsy3l2bdKHb_977LzXyupRx7Xkep6ROCtXhdxOOj1w3kO5cb03HVpd5Er0peqddX1rKz_Pu_h0U7uVbC7JzYoGvBIRDBInBM_sBwZAzHMgK-WMIlpIBZA8MRgxmH8AxZPX-AMRTNr8:1qW55d:MRx2zX-bhXLux3Cm__Hb9D9YWUYkcLb0Gl_Hgx-PUTA", "expire_date": "2023-08-30T01:12:49.654Z"}}, {"model": "task.task", "pk": 1, "fields": {"title": "Сортировка пузырьком / Bubble sort", "description": "Примечание к реализации. Возьмем в пример массив array = [4, 2, 5, 1, 3].\r\n    В данной сортировки \"исполнитель\" берет только 2 элемента, начиная с array[0], заканчивая\r\n    array[3], и сравнивает его со следующим. В случае если текущий меньше следующего,\r\n    меняет их местами, и переходит на 1 индекс вперед.\r\n    Для наглядности: array_now = [4, 2]\r\n    4 > 2, поэтому меняем местами. array_now = [2, 4]\r\n    Идем далее array_now = [2, 4, 5]. 4 < 5, поэтому НЕ меняем местами\r\n    Идем далее array_now = [2, 4, 5, 1]. 5 > 1, поэтому меняем местами.\r\n    Идем далее array_now = [2, 4, 1, 5, 3]. 5 > 3, поэтому меняем местами.\r\n    Итого за один проход получаем array_now = [2, 4, 1, 3, 5] и находим\r\n    самый большой элемент массива, который более можно не затрагивать.\r\n    Далее делаем такие же действия", "code": "def bubble_sort(array: list) -> list:\r\n    \"\"\"bubble_sort - реализует сортировку массива пузырьком\"\"\"\r\n    for bypass in range(1, len(array)):\r\n        for index in range(len(array) - bypass):\r\n            if array[index] > array[index + 1]:\r\n                array[index], array[index + 1] = array[index + 1], array[index]\r\n    return array", "pub_date": "2023-08-08T14:57:36.299Z", "time_update": "2023-08-08T14:57:36.299Z", "author": 1, "is_published": true, "category": 1, "subject": 1, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 2, "fields": {"title": "Сортировка вставкой / Insert sort", "description": "Пояснение к реализации. В пример можно привести строй солдат,\r\n    неправильно стоящий по росту.\r\n    Условный прапорщик берет первого солдата array[0], и видит только его.\r\n    В таком случае можно утверждать, что 1ый солдат array[0], сам в себе\r\n    отсортирован. Рассмотрим в качестве примера array = [4, 2, 5, 1, 3]\r\n    4, как единственный текущий элемент сам в себе отсортирован.\r\n    Далее обращаем внимание на второй элемент(солдата) array[1] = 2.\r\n    То есть \"рабочий массив\" array_now = [4, 2].\r\n    \"Прапорщик\" берет второго солдата(array[1] = 2), и ведет его влево,\r\n    до тех пор, пока солдат слева (элемент массива), не будет меньше\r\n    чем взятый элемент. В таком случае мы получаем array_now = [2, 4]\r\n    Смотрим на следующий элемент массива array_now = [2, 4, 5]\r\n    Берем добавленный элемент array[2] = 5 и идем влево до ближайшего\r\n    элемента, который меньше его. Такого элемента нет, поэтому 5 на своем месте\r\n    и array_now = [2, 4, 5]\r\n    Рассматриваем следующий элемент. array_now = [2, 4, 5, 1]\r\n    и берем его array_now[3] = 1. Ведем этот элемент по списку в поисках меньшего\r\n    чем он. Опишу действия наглядно на каждой встрече:\r\n    1) 1 < 5, поэтому меняем элементы местами - array_now = [2, 4, 1, 5]\r\n    2) 1 < 4, поэтому меняем элементы местами - array_now = [2, 1, 4, 5]\r\n    3) 1 < 2, поэтому меняем элементы местами - array_now = [1, 2, 4, 5]\r\n    Важно чтобы условие в реализации описывало остановку перестановок\r\n    до окончания массива, чтобы не выйти за его границы!!!\r\n    Ну и рассматриваем последний элемент массива array_now = [1, 2, 4, 5, 3]\r\n    array_now[4] = 3 перемещается по списку справа налево до встречи с элементом,\r\n    меньшим чем он. В итоге получаем сортированный массив array = [1, 2, 3, 4, 5]", "code": "def insert_sort(array: list) -> list:\r\n    \"\"\"insert_sort - реализует сортировку массива вставками\"\"\"\r\n\r\n    for top in range(1, len(array)):\r\n        # top - элемент который мы добавляем к отсортированной последовательности.\r\n        # В описании выше в пример возьмем array_now = [4] и мы берем следующий\r\n        # рассматриваемый элемент array_now = [4, 2]. В данном случае\r\n        # top = 2, и с ним мы работаем. Ну и далее по списку до последнего.\r\n        index = top\r\n        # Далее двигаемся справа налево, сравнивая элемент с предыдущими.\r\n        while index > 0 and array[index - 1] > array[index]:\r\n            # Важная заметка. При таком исполнении, где сначала идет проверка\r\n            # на index > 0, python не будет проверять 2ое условие, если первое\r\n            # False. Благодаря этому мы не выйдем за границы массива.\r\n            array[index], array[index - 1] = array[index - 1], array[index]\r\n            index -= 1\r\n    return array", "pub_date": "2023-08-08T14:59:45.734Z", "time_update": "2023-08-08T14:59:45.734Z", "author": 1, "is_published": true, "category": 1, "subject": 1, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 3, "fields": {"title": "Сортировка выбором / Choice sort", "description": "Примечание к реализации. Возьмем в пример массив array = [4, 2, 5, 1, 3].\r\n    Применим аналогию со строем солдат. В данном случае \"прапощик\"(выполняющая\r\n    функция) - дальновидный. То есть он берет первый элемент array[0] = 4,\r\n    и ищет ближайший наименьший элемент справа от него и меняет местами.\r\n    В таком случае рассмотрим первый ближайший элемент array_now = [4, 2]\r\n    Исполнитель видит, что 2 < 4 и меняет элементы местами. array_now = [2, 4]\r\n    Далее исполнитель выбирает новый элемент от array[0] = 2, и также ищет ближайший\r\n    наименьший элемент в массиве.\r\n    1) array_now = [2, 4, 5] - без изменений, рассматриваем следующий элемент\r\n    2) array_now = [2, 4, 5, 1] - 1 < 2, меняем местами. array_now = [1, 4, 5, 2]\r\n    3) Делаем заключительный заход с array_now[0] = 1, по всем элементам. Он наименьший,\r\n    поэтому остается на своем месте. Более с ним мы не работаем и берем второй элемент\r\n    array_now = [1, 2, 4, 5, 3], array_now[1] = 2 и производим такие же действия.\r\n    Таким образом мы для каждого индекса находим минимум из него и следующих элементов.", "code": "def choice_sort(array: list) -> list:\r\n    \"\"\"choice_sort - реализует сортировку массива выбором\"\"\"\r\n    for position in range(0, len(array) - 1):\r\n        for index in range(position + 1, len(array)):\r\n            if array[index] < array[position]:\r\n                array[index], array[position] = array[position], array[index]\r\n    return array", "pub_date": "2023-08-08T15:01:12.535Z", "time_update": "2023-08-08T19:22:44.301Z", "author": 1, "is_published": true, "category": 1, "subject": 1, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 4, "fields": {"title": "Бинарный поиск", "description": "Осуществляет бинарный поиск в отсортированной массиве методом рекурсии. Важно определить: \r\n1) Базовый случай, при котором рекурсия останавливается.\r\n2) Рекурсивный случай, при котором она осуществляет \"дробление\".\r\nРезультатом выполнения является индекс искомого значения, если оно присутствует, иначе -1.", "code": "def binary_search(array: list, lookup: int, left: int, right: int) -> int:\r\n    \"\"\"Осуществляет бинарный поиск в отсортированном массиве.\r\n    По умолчанию сортировка по возрастанию\"\"\"\r\n    if right <= left:\r\n        return -1\r\n    middle = (left + right) // 2\r\n    if lookup == array[middle]:\r\n        return middle\r\n    if lookup < array[middle]:\r\n        return binary_search(array, lookup, 0, middle)\r\n    return binary_search(array, lookup, middle + 1, right)", "pub_date": "2023-08-09T15:21:32.726Z", "time_update": "2023-08-09T15:21:32.726Z", "author": 1, "is_published": true, "category": 1, "subject": 2, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 5, "fields": {"title": "Сортировка слиянием", "description": "Сортировка слиянием. Осуществляется разбивкой исходного массива\r\nусловно пополам, и далее пополам до тех пор, пока не дойдет до 1го элемента\r\nи далее возвращается сравнивая поэлементно значения и добавляя их в массив.\r\nЗанимает O(NlogN) операций.", "code": "def merge_sort(array: list) -> list:\r\n    \"\"\"Слияние отсортированных массивов, упрощенный пример.\r\n    Слияние осуществляется за счет третьего незаполненного массива\r\n    путем сравнения поочередно элементов 1го и 2го массивов\r\n    и добавления наименьшего в результирующий массив \"\"\"\r\n    if len(array) < 2:\r\n        return array\r\n    left_array = [array[_] for _ in range(0, len(array) // 2)]\r\n    right_array = array[len(array) // 2: len(array)]\r\n    merge_sort(left_array)\r\n    merge_sort(right_array)\r\n    sorted_array = [0] * len(array)\r\n    left = right = sort = 0\r\n    while left < len(left_array) and right < len(right_array):\r\n        if left_array[left] <= right_array[right]:\r\n            sorted_array[sort] = left_array[left]\r\n            left += 1\r\n        else:\r\n            sorted_array[sort] = right_array[right]\r\n            right += 1\r\n        sort += 1\r\n    while left < len(left_array):\r\n        sorted_array[sort] = left_array[left]\r\n        left += 1\r\n        sort += 1\r\n    while right < len(right_array):\r\n        sorted_array[sort] = right_array[right]\r\n        right += 1\r\n        sort += 1\r\n    return sorted_array", "pub_date": "2023-08-09T15:24:46.976Z", "time_update": "2023-08-09T15:25:05.332Z", "author": 1, "is_published": true, "category": 1, "subject": 2, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 6, "fields": {"title": "Последовательность Фибоначчи рекурсивно", "description": "Рекурсивная функция, возвращающая значение\r\n    последовательности Фибоначчи по порядковому номеру.\r\n    Важно отметить, что это решение крайне неэффективно\r\n     и требует O(fib) операций. Кроме того важно учитывать,\r\n     что в стэке вызовов расходуется хначительное количество памяти.", "code": "def fib(number: int) -> int:\r\n    \"\"\"Рекурсивная функция, возвращающая значение\r\n    последовательности Фибоначчи по порядковому номеру.\r\n    Важно отметить, что это решение крайне неэффективно\r\n     и требует O(fib) операций. Кроме того важно учитывать,\r\n     что в стэке вызовов расходуется хначительное количество памяти.\"\"\"\r\n    if number <= 1:\r\n        return number\r\n    return fib(number - 1) + fib(number - 2)\r\n\r\n\r\nprint(fib(10))", "pub_date": "2023-08-09T16:22:29.467Z", "time_update": "2023-08-09T16:22:29.467Z", "author": 1, "is_published": true, "category": 1, "subject": 2, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 7, "fields": {"title": "Генерация чисел", "description": "Генерирует все числа с лидирующими, незначящими нулями\r\nв number_system системе счисления (number_system <= 10).\r\nДлина = amount_numbers", "code": "def generate_number(number_system: int, amount_numbers: int, prefix=None):\r\n    \"\"\"\r\n    Генерирует все числа с лидирующими, незначящими нулями\r\n    в number_system системе счисления (number_system <= 10).\r\n    Длина = amount_numbers\r\n    \"\"\"\r\n    prefix = prefix or []\r\n    if amount_numbers == 0:\r\n        print(*prefix, sep='')\r\n        return\r\n    for digit in range(number_system):\r\n        prefix.append(digit)\r\n        generate_number(number_system, amount_numbers - 1, prefix)\r\n        prefix.pop()", "pub_date": "2023-08-09T16:56:22.259Z", "time_update": "2023-08-09T16:56:22.259Z", "author": 1, "is_published": true, "category": 1, "subject": 2, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 8, "fields": {"title": "Геренация чисел двоичной СС", "description": "Рекурсивно генерирует все двоичные числа в заданных позициях", "code": "def gen_binary(number, prefix=None):\r\n    prefix = '' if prefix is None else prefix\r\n    if number == 0:\r\n        print(prefix)\r\n    else:\r\n        gen_binary(number - 1, prefix + '0')\r\n        gen_binary(number - 1, prefix + '1')", "pub_date": "2023-08-09T18:10:18.255Z", "time_update": "2023-08-09T18:10:18.255Z", "author": 1, "is_published": true, "category": 1, "subject": 2, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 9, "fields": {"title": "Сортировка Тони Хоара", "description": "Сортировка Тони Хоара. В массиве выбирается барьерный элемент\r\n    и массив делится на 3 \"новых\" массива. В левом все элементы, меньшие\r\n    барьерного, в центральном все элементы равные барьерному, в правом\r\n    все элементы большие барьерного. Обычно барьерный элемент берется в диапазоне\r\n    текущего массива, но для примера возьмем элемент из середины массива,\r\n    чтобы избежать худшего случая, когда массив уже отсортирован", "code": "def quicksort(array: list):\r\n    \"\"\"Сортировка Тони Хоара. В массиве выбирается барьерный элемент\r\n    и массив делится на 3 \"новых\" массива. В левом все элементы, меньшие\r\n    барьерного, в центральном все элементы равные барьерному, в правом\r\n    все элементы большие барьерного. Обычно барьерный элемент берется в диапазоне\r\n    текущего массива, но для примера возьмем элемент из середины массива,\r\n    чтобы избежать худшего случая, когда массив уже отсортирован\"\"\"\r\n    if len(array) < 2:\r\n        return array\r\n    barrier = array[(len(array) // 2)]\r\n    left_array, middle_array, right_array = [], [], []\r\n    for index in range(len(array)):\r\n        if array[index] < barrier:\r\n            left_array.append(array[index])\r\n        elif array[index] > barrier:\r\n            right_array.append(array[index])\r\n        else:\r\n            middle_array.append(array[index])\r\n    quicksort(left_array)\r\n    quicksort(right_array)\r\n    counter = 0\r\n    for number in left_array + middle_array + right_array:\r\n        array[counter] = number\r\n        counter += 1\r\n    return array\r\n\r\n\r\ndef check_sorted(array: list, ascending=True):\r\n    \"\"\"Проверяет отсортирован ли массив за O(N). По умолчанию проверка\r\n    сортировки по возрастанию\"\"\"\r\n    flag = True\r\n    check = 2 * int(ascending) - 1\r\n    for index in range(0, len(array) - 1):\r\n        if check * array[index] > check * array[index + 1]:\r\n            flag = False\r\n            break\r\n    return flag\r\n\r\n\r\nunsorted_array = [12, 2, 51, 22, 3, 1, 14, 9, 16, 3, 4, 12, 29, 11, 9]\r\nprint(quicksort(unsorted_array))", "pub_date": "2023-08-09T18:15:57.473Z", "time_update": "2023-08-09T18:15:57.473Z", "author": 1, "is_published": true, "category": 1, "subject": 2, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 10, "fields": {"title": "Пример тестирования Assert 1", "description": "В данном случае тестируем функцию квадратичной сортировки \"Пузырьком\"", "code": "def bubble_sort(array: list) -> list:\r\n    for index in range(1, len(array)):\r\n        for bubble in range(len(array) - index):\r\n            if array[bubble] > array[bubble + 1]:\r\n                (array[bubble],\r\n                 array[bubble + 1]) = (array[bubble + 1],\r\n                                       array[bubble])\r\n    return array\r\n\r\n\r\ndef test_bubble_search():\r\n    first_case = [3, 1, 2, 4, 0]\r\n    second_case = []\r\n    third_case = [1, 1, 1, 1, 1]\r\n    assert bubble_sort(first_case) == [0, 1, 2, 3, 4], (f'Функция bubble_sort '\r\n                                                        f'работает неверно с {first_case}')\r\n    assert bubble_sort(second_case) == [], (f'Функция bubble_sort '\r\n                                            f'работает неверно с {second_case}')\r\n    assert bubble_sort(third_case) == [1, 1, 1, 1, 1], (f'Функция bubble_sort '\r\n                                                        f'работает неверно с {third_case}')", "pub_date": "2023-08-10T16:11:58.764Z", "time_update": "2023-08-10T16:11:58.764Z", "author": 1, "is_published": true, "category": 4, "subject": 3, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 11, "fields": {"title": "Декоратор измерения времени", "description": "Пример реализации простейшего декоратора измерения времени работы декорируемой функции.", "code": "from functools import wraps\r\nimport time\r\n\r\nunsorted = [9, 7, 0, 3, 6, 1, 4, 5, 2, 8]\r\n\r\n\r\ndef decorator(func):\r\n    @wraps(func)\r\n    def wrapper(*args, **kwargs):\r\n        print(f'Функция {func.__name__} начала свою работу')\r\n        start = time.time()\r\n        result = func(*args, **kwargs)\r\n        time.sleep(1)\r\n        diff_time = round((time.time() - start), 1)\r\n        print(f'Функция {func.__name__} закончила свою работу, затрачено {diff_time} с.')\r\n        return result\r\n\r\n    return wrapper\r\n\r\n\r\n@decorator\r\ndef bubble_sort(array: list) -> list:\r\n    for index in range(1, len(array)):\r\n        for bubble in range(len(array) - index):\r\n            if array[bubble] > array[bubble + 1]:\r\n                (array[bubble],\r\n                 array[bubble + 1]) = (array[bubble + 1],\r\n                                       array[bubble])\r\n    return array\r\n\r\n\r\nprint(bubble_sort(unsorted))", "pub_date": "2023-08-10T18:10:39.307Z", "time_update": "2023-08-10T18:10:39.307Z", "author": 1, "is_published": true, "category": 3, "subject": 5, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 12, "fields": {"title": "Метод двух указателей", "description": "Осуществляет поиск двух значений в массиве, в сумме дающих искомый элемент.\r\n    Необходимое условие - массив отсортирован по неубыванию. Асимптотика O(N/2).\r\n    В случае если таких чисел не существует, возвращает -1, -1.", "code": "def two_pointer(array: list, number: int) -> (int, int):\r\n    \"\"\"\r\n    Осуществляет поиск двух значений в массиве, в сумме дающих искомый элемент.\r\n    Необходимое условие - массив отсортирован по неубыванию. Асимптотика O(N/2).\r\n    В случае если таких чисел не существует, возвращает -1, -1.\r\n    \"\"\"\r\n    left = 0\r\n    right = len(array) - 1\r\n    while left < right:\r\n        current_sum = array[left] + array[right]\r\n        if current_sum == number:\r\n            return array[left], array[right]\r\n        if current_sum < number:\r\n            left += 1\r\n        else:\r\n            right -= 1\r\n    return -1, -1", "pub_date": "2023-08-12T11:42:31.154Z", "time_update": "2023-08-12T11:43:36.985Z", "author": 1, "is_published": true, "category": 1, "subject": 7, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 13, "fields": {"title": "Метод двух указателей с дополнительной памятью", "description": "Если не хочется сортировать тяжёлые блины, можно использовать для решения этой задачи дополнительную память. Например, позвать тренера, который наизусть помнит вес всех блинов в спортзале. В этом случае алгоритм будет такой: можно в любом порядке перебирать блины и, вытащив очередной (допустим, с весом \r\n�\r\nA), спрашивать: «А есть ли у вас блин с весом \r\n�\r\n−\r\n�\r\nX−A?». Когда консультант ответит «Да, есть такой» — можно оставить себе текущий блин, взять тот, что с весом \r\n�\r\n−\r\n�\r\nX−A, и пойти заниматься.\r\nВ этой ситуации важно, чтобы тренер действительно помнил вес всех блинов, а не бегал каждый раз проверять наличие нужного блина — в таком случае скорость не будет отличаться от наивного алгоритма. Метод с «дополнительной памятью» будет работать быстро, но у него есть недостаток: тренер может попросить денег за свои услуги.\r\nВ программировании это означает, что для решения задачи можно использовать вспомогательную структуру, которая называется «структура данных поиска». Она умеет быстро наполняться содержимым и эффективно отвечать на вопросы вроде «Есть ли у тебя элемент Y?». Такой структурой может служить set, map или dict.", "code": "def twosum_extra_ds(numbers, X):\r\n    # Создаём вспомогательную структуру данных с быстрым поиском элемента.\r\n    previous = set()\r\n\r\n    for A in numbers:\r\n        Y = X - A\r\n        if Y in previous:\r\n            return A, Y\r\n        else:\r\n            previous.add(A)\r\n\r\n    # Если ничего не нашлось в цикле, значит, нужной пары элементов в массиве нет.\r\n    return None, None", "pub_date": "2023-08-12T11:45:45.045Z", "time_update": "2023-08-12T11:46:36.222Z", "author": 1, "is_published": true, "category": 1, "subject": 7, "likes": [], "dislikes": []}}, {"model": "task.task", "pk": 14, "fields": {"title": "Реализация stack на массиве", "description": "Пример тривиальной реализации стека на массиве и функциях к нему. Также в примере реализовано тестирование с помощью модуля doctest.", "code": "\"\"\"\r\n>>> clear()\r\n>>> is_empty()\r\nTrue\r\n>>> push(1)\r\n>>> push(2)\r\n>>> push(3)\r\n>>> pop()\r\n3\r\n>>> pop()\r\n2\r\n>>> pop()\r\n1\r\n>>> is_empty()\r\nTrue\r\n\"\"\"\r\n\r\n_stack = []\r\n\r\n\r\ndef push(value):\r\n    \"\"\"Добавляет элемент value в конец стека\r\n    >>> push(5)\r\n    >>> _stack[-1]\r\n    5\r\n    \"\"\"\r\n    _stack.append(value)\r\n\r\n\r\ndef pop():\r\n    x = _stack.pop()\r\n    return x\r\n\r\n\r\ndef clear():\r\n    _stack.clear()\r\n\r\n\r\ndef is_empty():\r\n    return len(_stack) == 0\r\n\r\n\r\nif __name__ == '__main__':\r\n    import doctest\r\n\r\n    doctest.testmod(verbose=True)", "pub_date": "2023-08-16T01:30:13.430Z", "time_update": "2023-08-16T01:31:57.593Z", "author": 3, "is_published": true, "category": 5, "subject": 6, "likes": [], "dislikes": [2]}}, {"model": "task.task", "pk": 15, "fields": {"title": "Проверка корректности скобочной последовательности", "description": "Данный алгоритм реализован на примере стэка, оформленного как массив с функциями. Также в качестве теста применен модуль doctest. В данном алгоритме рассматриваются скобочные комбинации, состоящие только из ()[].", "code": "\"\"\"\r\n    Проверка корректности скобочного выражения.\r\n    Корректные скобочные выражения:\r\n    1) A = \"\" - пустая послеовательность\r\n    2) B = (A)\r\n    3) C = AB\r\n\"\"\"\r\n\r\n_stack = []\r\n\r\n\r\ndef push(value):\r\n    \"\"\"Добавляет элемент value в конец стека\r\n    >>> push(5)\r\n    >>> _stack[-1]\r\n    5\r\n    \"\"\"\r\n    _stack.append(value)\r\n\r\n\r\ndef pop():\r\n    x = _stack.pop()\r\n    return x\r\n\r\n\r\ndef clear():\r\n    _stack.clear()\r\n\r\n\r\ndef is_empty():\r\n    return len(_stack) == 0\r\n\r\n\r\nbrackets = {\r\n    '(': ')',\r\n    '[': ']'\r\n}\r\n\r\n\r\ndef check_bracket_sequence(s: str):\r\n    \"\"\"Проверяет корректность скобочной последовательности из () []\r\n    >>> check_bracket_sequence(\"()[[(())]]()\")\r\n    True\r\n    >>> check_bracket_sequence(\"([[]))\")\r\n    False\r\n    \"\"\"\r\n    for bracket in s:\r\n        if bracket not in \"()[]\":\r\n            continue\r\n        if bracket in brackets.keys():\r\n            push(bracket)\r\n        else:\r\n            assert bracket in brackets.values(), ('Ожидалась закрывающая скобка:'\r\n                                                  + str(bracket))\r\n            if is_empty():\r\n                return False\r\n            left = pop()\r\n            assert left in brackets.keys(), ('Ожидалась открывающая скобка:'\r\n                                             + str(bracket))\r\n            if left == '(':\r\n                right = ')'\r\n            elif left == '[':\r\n                right = ']'\r\n            if right != bracket:\r\n                return False\r\n    return is_empty()\r\n\r\n\r\nif __name__ == '__main__':\r\n    import doctest\r\n\r\n    doctest.testmod(verbose=False)", "pub_date": "2023-08-16T02:04:31.871Z", "time_update": "2023-08-16T02:04:31.871Z", "author": 2, "is_published": true, "category": 1, "subject": 6, "likes": [1, 2, 3], "dislikes": [4]}}, {"model": "task.category", "pk": 1, "fields": {"title": "Алгоритмы", "description": "В данной категории представлены различные алгоритмические задачи, актуальные для меня"}}, {"model": "task.category", "pk": 2, "fields": {"title": "ООП (Объектно - ориентированное программирование)", "description": "В данной категории я затрагиваю интересующие меня темы по ООП."}}, {"model": "task.category", "pk": 3, "fields": {"title": "Общий Python", "description": "Здесь будут интересующие меня темы по Python в целом"}}, {"model": "task.category", "pk": 4, "fields": {"title": "Тестирование", "description": "В данной категории будут представлены различные варианты тестирования, которые меня интересуют"}}, {"model": "task.category", "pk": 5, "fields": {"title": "Структуры данных", "description": "В данной категории будут рассматриваться структуры данных, которые являются актуальными для меня"}}, {"model": "task.category", "pk": 6, "fields": {"title": "DJANGO", "description": "В этой категории будут темы, интересующие меня по DJANGO"}}, {"model": "task.category", "pk": 7, "fields": {"title": "DRF (API)", "description": "В этой категории будут темы, интересующие меня по API REST от Django"}}, {"model": "task.subject", "pk": 1, "fields": {"title": "Квадратичные сортировки", "description": "В данной теме представлены три типа квадратичных сортировок:\r\n1) Сортировка вставкой (insert sort)\r\n2) Сортировка выбором (choise sort)\r\n3) Сортировка пузырьком (bubble sort)", "category": 1}}, {"model": "task.subject", "pk": 2, "fields": {"title": "Рекурсия", "description": "В данной теме приведены актуальные для меня задачи по рекурсии", "category": 1}}, {"model": "task.subject", "pk": 3, "fields": {"title": "Тестирование Assert", "description": "Простейший из вариантов быстрого тестирования функций или участков кода.", "category": 4}}, {"model": "task.subject", "pk": 4, "fields": {"title": "Тестирование Unittest", "description": "Буду выкладывать здесь интересующие меня решения по Unittest", "category": 4}}, {"model": "task.subject", "pk": 5, "fields": {"title": "Декораторы", "description": "В данной теме я буду затрагивать интересующие меня декораторы. Как простейшие, по типу измерения времени, так и более сложные", "category": 3}}, {"model": "task.subject", "pk": 6, "fields": {"title": "Стэк (структура данных)", "description": "Структура данных, представляющая из себя упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека. Притом первым из стека удаляется элемент, который был помещен туда последним, то есть в стеке реализуется стратегия «последним вошел — первым вышел» (last-in, first-out — LIFO). Примером стека в реальной жизни может являться стопка тарелок: когда мы хотим вытащить тарелку, мы должны снять все тарелки выше. Вернемся к описанию операций стека:\r\n\r\n𝚎𝚖𝚙𝚝𝚢\r\n — проверка стека на наличие в нем элементов,\r\n𝚙𝚞𝚜𝚑\r\n (запись в стек) — операция вставки нового элемента,\r\n𝚙𝚘𝚙\r\n (снятие со стека) — операция удаления нового элемента.", "category": 5}}, {"model": "task.subject", "pk": 7, "fields": {"title": "Эффективные алгоритмы решения задачи 2-SUM", "description": "", "category": 1}}, {"model": "task.taskimage", "pk": 1, "fields": {"image": "photos/2023/08/08/Снимок_экрана_2023-08-08_в_15.57.08.png", "task": 1}}, {"model": "task.taskimage", "pk": 2, "fields": {"image": "photos/2023/08/08/Снимок_экрана_2023-08-08_в_15.58.35.png", "task": 2}}, {"model": "task.taskimage", "pk": 3, "fields": {"image": "photos/2023/08/08/Снимок_экрана_2023-08-08_в_16.00.50.png", "task": 3}}, {"model": "task.taskimage", "pk": 4, "fields": {"image": "photos/2023/08/08/Снимок_экрана_2023-08-08_в_17.13.17.png", "task": 3}}, {"model": "task.taskimage", "pk": 5, "fields": {"image": "photos/2023/08/09/Снимок_экрана_2023-08-09_в_16.21.05.png", "task": 4}}, {"model": "task.taskimage", "pk": 6, "fields": {"image": "photos/2023/08/09/Снимок_экрана_2023-08-09_в_16.24.28.png", "task": 5}}, {"model": "task.taskimage", "pk": 7, "fields": {"image": "photos/2023/08/09/Снимок_экрана_2023-08-09_в_17.22.13.png", "task": 6}}, {"model": "task.taskimage", "pk": 8, "fields": {"image": "photos/2023/08/09/Снимок_экрана_2023-08-09_в_17.55.52.png", "task": 7}}, {"model": "task.comment", "pk": 1, "fields": {"task": 11, "text": "Тест 1", "author": 1, "pub_date": "2023-08-11T15:14:57.783Z", "time_update": "2023-08-11T15:14:57.790Z"}}, {"model": "task.comment", "pk": 2, "fields": {"task": 11, "text": "Тест 2", "author": 1, "pub_date": "2023-08-11T15:30:47.600Z", "time_update": "2023-08-11T15:30:47.630Z"}}, {"model": "task.comment", "pk": 3, "fields": {"task": 11, "text": "Тест 3", "author": 1, "pub_date": "2023-08-11T15:30:53.949Z", "time_update": "2023-08-11T15:30:53.949Z"}}, {"model": "task.comment", "pk": 4, "fields": {"task": 11, "text": "Тест 4", "author": 1, "pub_date": "2023-08-11T15:30:59.308Z", "time_update": "2023-08-11T15:30:59.309Z"}}, {"model": "task.comment", "pk": 5, "fields": {"task": 11, "text": "Тест 5", "author": 1, "pub_date": "2023-08-11T15:31:12.125Z", "time_update": "2023-08-11T15:31:12.125Z"}}, {"model": "task.comment", "pk": 6, "fields": {"task": 11, "text": "Тест 6", "author": 1, "pub_date": "2023-08-11T15:31:18.993Z", "time_update": "2023-08-11T15:31:19.000Z"}}, {"model": "task.comment", "pk": 7, "fields": {"task": 11, "text": "Тест 7", "author": 1, "pub_date": "2023-08-11T15:31:23.654Z", "time_update": "2023-08-11T15:31:23.654Z"}}, {"model": "task.comment", "pk": 8, "fields": {"task": 11, "text": "Тест 8", "author": 1, "pub_date": "2023-08-11T15:31:28.768Z", "time_update": "2023-08-11T15:31:28.770Z"}}, {"model": "task.comment", "pk": 9, "fields": {"task": 11, "text": "Тест 9", "author": 1, "pub_date": "2023-08-11T15:31:33.533Z", "time_update": "2023-08-11T15:31:33.534Z"}}, {"model": "task.comment", "pk": 10, "fields": {"task": 11, "text": "Тест 10", "author": 1, "pub_date": "2023-08-11T15:31:40.544Z", "time_update": "2023-08-11T15:31:40.549Z"}}, {"model": "task.comment", "pk": 11, "fields": {"task": 11, "text": "Тест 11", "author": 1, "pub_date": "2023-08-11T15:31:44.952Z", "time_update": "2023-08-11T15:31:44.953Z"}}, {"model": "task.comment", "pk": 12, "fields": {"task": 13, "text": "Тест комментария от нового пользователя", "author": 1, "pub_date": "2023-08-13T13:11:11.165Z", "time_update": "2023-08-13T13:11:11.167Z"}}, {"model": "task.comment", "pk": 13, "fields": {"task": 13, "text": "test", "author": 1, "pub_date": "2023-08-13T13:14:46.727Z", "time_update": "2023-08-13T13:14:46.728Z"}}, {"model": "task.comment", "pk": 14, "fields": {"task": 13, "text": "test again", "author": 1, "pub_date": "2023-08-13T18:52:12.093Z", "time_update": "2023-08-13T18:52:12.094Z"}}, {"model": "task.comment", "pk": 15, "fields": {"task": 13, "text": "awdwadasdasd", "author": 1, "pub_date": "2023-08-13T18:54:30.684Z", "time_update": "2023-08-13T18:54:30.685Z"}}, {"model": "task.comment", "pk": 16, "fields": {"task": 13, "text": "awdwadasdasd", "author": 1, "pub_date": "2023-08-13T18:55:35.382Z", "time_update": "2023-08-13T18:55:35.395Z"}}]